let badW = [
  "http://",
  ".com",
  "discord.gg",
  "https://",
  "www.",
  "@everyone",
  "@here",
  "discord.app",
  ".net",
  ".xyz",
  ".tk",
  ".pw",
  ".io",
  ".me",
  ".gg",
  ".gl",
  ".org",
  ".com.tr",
  ".biz",
  ".party",
  ".rf.gd",
  ".az"
];

client.on("message", message => {
  if (
    message.author.id === "735874386200100974" ||
    message.author.id === "522793997312327726"
  )
    return;

  if (!message.member.hasPermission("MANAGE_MESSAGES")) {
    if (message.content.includes(badW[0])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[1])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[2])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[3])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[4])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[5])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[6])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[7])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[8])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[9])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[10])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[11])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[12])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[13])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[14])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[15])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[16])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[17])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[18])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[19])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else if (message.content.includes(badW[20])) {
      message.delete();
      message.reply("You don't have manage_message permission");
    } else {
      return;
    }
  }
});

client.on("message", message => {
  let data = "this is a bad words\n";
  let args = message.content.split(" ");
  let i;
  if (args[0] === prefix + "badData") {
    let embed = new Discord.RichEmbed().setColor("RANDOM");
    let des = "";

    for (i = 0; i < badW.length; i++) {
      des = des + "\n" + i + "- `" + badW[i] + "`";
    }
    embed.setDescription(des);
    message.channel.send(embed);
  }
});


const usersMap = new Map();
const LIMIT = 7;
const TIME = 300000;
const DIFF = 7000;

const roll = "Spam Muted";

let spam = JSON.parse(fs.readFileSync("./spam.json", "utf8"));

client.on("message", message => {
  const muteRole = message.member.guild.roles.find(role => role.name === roll);
  if (!muteRole) {
    let muteRole = message.member.guild
      .createRole({
        name: roll,
        color: "#000000",
        permissions: []
      })
      .then(R => {
        message.member.guild.channels.forEach(channel => {
          channel.overwritePermissions(R, {
            SEND_MESSAGES: false,
            CONNECT: false
          });
        });
      });
  }
});

client.on("message", message => {
  if (
    message.author.id === "735874386200100974" ||
    message.author.id === "522793997312327726"
  )
    return;
  if (message.author.bot) return;
  if (usersMap.has(message.author.id)) {
    const userData = usersMap.get(message.author.id);
    const { lastMessage, timer } = userData;
    const difference = message.createdTimestamp - lastMessage.createdTimestamp;
    let msgCount = userData.msgCount;
    console.log(difference);
    if (difference > DIFF) {
      clearTimeout(timer);
      userData.msgCount = 1;
      userData.lastMessage = message;
      userData.timer = setTimeout(() => {
        usersMap.delete(message.author.id);
      }, TIME);
      usersMap.set(message.author.id, userData);
    } else {
      ++msgCount;
      if (parseInt(msgCount) === LIMIT) {
        const muteRole = message.member.guild.roles.find(
          role => role.name === roll
        );

        if (!muteRole) {
          muteRole = message.guild
            .createRole({
              name: roll,
              color: "#000000",
              permissions: []
            })
            .then(R => {
              message.guild.channels.forEach(channel => {
                channel.overwritePermissions(R, {
                  SEND_MESSAGES: false,
                  CONNECT: false
                });
              });
            });
          message.member.addRole(muteRole);
          message.channel.bulkDelete(8, true);
        } else {
          message.member.addRole(muteRole);
          message.channel.bulkDelete(8, true);
        }
        message.channel.send(`<@${message.author.id}> You have been muted.`);
        if (!spam[message.guild.id + message.author.id]) {
          spam[message.guild.id + message.author.id] = "on";
        } else if (spam[message.guild.id + message.author.id] === "off") {
          spam[message.guild.id + message.author.id] = "on";
        }

        fs.writeFile("./spam.json", JSON.stringify(spam), err => {
          if (err) console.error(err);
        });

        setTimeout(() => {
          message.member.removeRole(muteRole);
          message.channel.send(`<@${message.author.id}> You have been unmuted`);
          if (spam[message.guild.id + message.author.id] === "on") {
            spam[message.guild.id + message.author.id] = "off";
          }

          fs.writeFile("./spam.json", JSON.stringify(spam), err => {
            if (err) console.error(err);
          });
        }, TIME);
      } else {
        userData.msgCount = msgCount;
        usersMap.set(message.author.id, userData);
      }
    }
  } else {
    let fn = setTimeout(() => {
      usersMap.delete(message.author.id);
    }, TIME);
    usersMap.set(message.author.id, {
      msgCount: 1,
      lastMessage: message,
      timer: fn
    });
  }

  fs.writeFile("./spam.json", JSON.stringify(spam), err => {
    if (err) console.error(err);
  });
});

client.on("guildMemberAdd", member => {
  if (member.id === "735874386200100974" || member.id === "522793997312327726")
    return;
  if (spam[member.guild.id + member.id] === "on") {
    const muteRole = member.guild.roles.find(role => role.name === roll);

    if (!muteRole) {
      muteRole = member.guild
        .createRole({
          name: roll,
          color: "#000000",
          permissions: []
        })
        .then(R => {
          member.guild.channels.forEach(channel => {
            channel.overwritePermissions(R, {
              SEND_MESSAGES: false,
              CONNECT: false
            });
          });
        });
      member.addRole(muteRole);
    } else {
      member.addRole(muteRole);
    }
  }
});

async function clearChannel(channel, n = 0, old = false) {
  let collected = await channel.fetchMessages();
  if (collected.size > 0) {
    if (old) {
      for (let msg of collected.array()) {
        await msg.delete();
        n++;
      }
    } else {
      let deleted = await channel.bulkDelete(100, true);
      if (deleted.size < collected.size) old = true;
      n += deleted;
    }

    return n + (await clearChannel(channel, old));
  } else return 0;
}
